#include <stdio.h>
#include <stdint.h>

#define BIG_ENDIAN	// Define if host CPU is Big Endian

typedef bool pin;

typedef uint8_t Byte;
typedef uint16_t Word;
typedef uint8_t Reg8;
typedef uint16_t Reg16;
typedef uint32_t Reg32;

#define RAMSIZE 65536

Byte Ram[RAMSIZE];	// RAM Memory

pin Clock = 1;
pin nReset = 1;

Byte Instr;	// Current (fetched) instruction
Byte M;		// Current (fetched) memory byte

// Instruction Decoding    x x y y y z z z
//                         - - p p q - - -
//
#define GetX(i) ((i & 0b11000000) >> 6)
#define GetY(i) ((i & 0b00111000) >> 3)
#define GetZ(i)  (i & 0b00000111)
#define GetP(i)	((i & 0b00110000) >> 4)
#define GetQ(i) ((i & 0b00001000) >> 3)

// Register table
// 0  1  2  3  4  5  6   7   8   9   10 12 14 15 16 17 18 19 20 21 22 23 24 25
// B  C  D  E  H  L  IXh IXl IYh IYl SP PC A  F  B' C' D' E' H' L' A' F' I  R
Reg8 Regs[26];

#ifdef BIG_ENDIAN
//Pointers to the 8 bit registers
Reg8 *pB = &Regs[1];
Reg8 *pC = &Regs[0];
Reg8 *pD = &Regs[3];
Reg8 *pE = &Regs[2];
Reg8 *pH = &Regs[5];
Reg8 *pL = &Regs[4];
Reg8 *pIXh = &Regs[7];
Reg8 *pIXl = &Regs[6];
Reg8 *pIYh = &Regs[9];
Reg8 *pIYl = &Regs[8];
Reg8 *pA = &Regs[15];
Reg8 *pF = &Regs[14];
Reg8 *pB_ = &Regs[17];
Reg8 *pC_ = &Regs[16];
Reg8 *pD_ = &Regs[19];
Reg8 *pE_ = &Regs[18];
Reg8 *pH_ = &Regs[21];
Reg8 *pL_ = &Regs[20];
Reg8 *pA_ = &Regs[23];
Reg8 *pF_ = &Regs[22];
Reg8 *pI = &Regs[25];
Reg8 *pR = &Regs[24];
#else
Reg8 *pB = &Regs[0];
Reg8 *pC = &Regs[1];
Reg8 *pD = &Regs[2];
Reg8 *pE = &Regs[3];
Reg8 *pH = &Regs[4];
Reg8 *pL = &Regs[5];
Reg8 *pIXh = &Regs[6];
Reg8 *pIXl = &Regs[7];
Reg8 *pIYh = &Regs[8];
Reg8 *pIYl = &Regs[9];
Reg8 *pA = &Regs[14];
Reg8 *pF = &Regs[15];
Reg8 *pB_ = &Regs[16];
Reg8 *pC_ = &Regs[17];
Reg8 *pD_ = &Regs[18];
Reg8 *pE_ = &Regs[19];
Reg8 *pH_ = &Regs[20];
Reg8 *pL_ = &Regs[21];
Reg8 *pA_ = &Regs[22];
Reg8 *pF_ = &Regs[23];
Reg8 *pI = &Regs[24];
Reg8 *pR = &Regs[25];
#endif

// Pointers to the 16 bit registers
Reg16 *pBC = (Reg16*)&Regs[0];
Reg16 *pDE = (Reg16*)&Regs[2];
Reg16 *pHL = (Reg16*)&Regs[4];
Reg16 *pIX = (Reg16*)&Regs[6];
Reg16 *pIY = (Reg16*)&Regs[8];
Reg16 *pSP = (Reg16*)&Regs[10];
Reg16 *pPC = (Reg16*)&Regs[12];
Reg16 *pAF = (Reg16*)&Regs[14];
Reg16 *pBC_ = (Reg16*)&Regs[16];
Reg16 *pDE_ = (Reg16*)&Regs[18];
Reg16 *pHL_ = (Reg16*)&Regs[20];
Reg16 *pAF_ = (Reg16*)&Regs[22];

// 8 Bit registers (renaming the pointers)
#define B (*pB)
#define C (*pC)
#define D (*pD)
#define E (*pE)
#define H (*pH)
#define L (*pL)
#define IXh (*pIXh)
#define IXl (*pIXl)
#define IYh (*pIYh)
#define IYl (*pIYl)
#define A (*pA)
#define F (*pF)
#define B_ (*pB_)
#define C_ (*pC_)
#define D_ (*pD_)
#define E_ (*pE_)
#define H_ (*pH_)
#define L_ (*pL_)
#define A_ (*pA_)
#define F_ (*pF_)
#define I (*pI)
#define R (*pR)

// 16 Bit registers (renaming the pointers)
#define BC (*pBC)
#define DE (*pDE)
#define HL (*pHL)
#define IX (*pIX)
#define IY (*pIY)
#define SP (*pSP)
#define PC (*pPC)
#define AF (*pAF)
#define BC_ (*pBC_)
#define DE_ (*pDE_)
#define HL_ (*pHL_)
#define AF_ (*pAF_)

// Flags          (SZ5H3PNC)
#define fS	(F & 0b10000000)
#define fZ	(F & 0b01000000)
#define	fY	(F & 0b00100000)
#define fH	(F & 0b00010000)
#define fX	(F & 0b00001000)
#define fP	(F & 0b00000100)
#define fN	(F & 0b00000010)
#define fC	(F & 0b00000001)

// Data tables
Reg16 *rp[4];	// BC DE HL SP
Reg16 *rp2[4];	// BC DE HL AF
Reg8 *r[8];		// B C D E H L (HL) A

/* parityTable[i] = (number of 1's in i is odd) ? 0 : 4, i = 0..255 */
static const Byte parityTable[256] = {
	4,0,0,4,0,4,4,0,0,4,4,0,4,0,0,4,
	0,4,4,0,4,0,0,4,4,0,0,4,0,4,4,0,
	0,4,4,0,4,0,0,4,4,0,0,4,0,4,4,0,
	4,0,0,4,0,4,4,0,0,4,4,0,4,0,0,4,
	0,4,4,0,4,0,0,4,4,0,0,4,0,4,4,0,
	4,0,0,4,0,4,4,0,0,4,4,0,4,0,0,4,
	4,0,0,4,0,4,4,0,0,4,4,0,4,0,0,4,
	0,4,4,0,4,0,0,4,4,0,0,4,0,4,4,0,
	0,4,4,0,4,0,0,4,4,0,0,4,0,4,4,0,
	4,0,0,4,0,4,4,0,0,4,4,0,4,0,0,4,
	4,0,0,4,0,4,4,0,0,4,4,0,4,0,0,4,
	0,4,4,0,4,0,0,4,4,0,0,4,0,4,4,0,
	4,0,0,4,0,4,4,0,0,4,4,0,4,0,0,4,
	0,4,4,0,4,0,0,4,4,0,0,4,0,4,4,0,
	0,4,4,0,4,0,0,4,4,0,0,4,0,4,4,0,
	4,0,0,4,0,4,4,0,0,4,4,0,4,0,0,4,
};

/* incTable[i] = (i & 0xa8) | (((i & 0xff) == 0) << 6) | (((i & 0xf) == 0) << 4), i = 0..256 */
static const Byte incTable[257] = {
	80,  0,  0,  0,  0,  0,  0,  0,  8,  8,  8,  8,  8,  8,  8,  8,
	16,  0,  0,  0,  0,  0,  0,  0,  8,  8,  8,  8,  8,  8,  8,  8,
	48, 32, 32, 32, 32, 32, 32, 32, 40, 40, 40, 40, 40, 40, 40, 40,
	48, 32, 32, 32, 32, 32, 32, 32, 40, 40, 40, 40, 40, 40, 40, 40,
	16,  0,  0,  0,  0,  0,  0,  0,  8,  8,  8,  8,  8,  8,  8,  8,
	16,  0,  0,  0,  0,  0,  0,  0,  8,  8,  8,  8,  8,  8,  8,  8,
	48, 32, 32, 32, 32, 32, 32, 32, 40, 40, 40, 40, 40, 40, 40, 40,
	48, 32, 32, 32, 32, 32, 32, 32, 40, 40, 40, 40, 40, 40, 40, 40,
	144,128,128,128,128,128,128,128,136,136,136,136,136,136,136,136,
	144,128,128,128,128,128,128,128,136,136,136,136,136,136,136,136,
	176,160,160,160,160,160,160,160,168,168,168,168,168,168,168,168,
	176,160,160,160,160,160,160,160,168,168,168,168,168,168,168,168,
	144,128,128,128,128,128,128,128,136,136,136,136,136,136,136,136,
	144,128,128,128,128,128,128,128,136,136,136,136,136,136,136,136,
	176,160,160,160,160,160,160,160,168,168,168,168,168,168,168,168,
	176,160,160,160,160,160,160,160,168,168,168,168,168,168,168,168, 80
};

/* decTable[i] = (i & 0xa8) | (((i & 0xff) == 0) << 6) | (((i & 0xf) == 0xf) << 4) | 2, i = 0..255 */
static const Byte decTable[256] = {
	66,  2,  2,  2,  2,  2,  2,  2, 10, 10, 10, 10, 10, 10, 10, 26,
	 2,  2,  2,  2,  2,  2,  2,  2, 10, 10, 10, 10, 10, 10, 10, 26,
	34, 34, 34, 34, 34, 34, 34, 34, 42, 42, 42, 42, 42, 42, 42, 58,
	34, 34, 34, 34, 34, 34, 34, 34, 42, 42, 42, 42, 42, 42, 42, 58,
	 2,  2,  2,  2,  2,  2,  2,  2, 10, 10, 10, 10, 10, 10, 10, 26,
	 2,  2,  2,  2,  2,  2,  2,  2, 10, 10, 10, 10, 10, 10, 10, 26,
	34, 34, 34, 34, 34, 34, 34, 34, 42, 42, 42, 42, 42, 42, 42, 58,
	34, 34, 34, 34, 34, 34, 34, 34, 42, 42, 42, 42, 42, 42, 42, 58,
	130,130,130,130,130,130,130,130,138,138,138,138,138,138,138,154,
	130,130,130,130,130,130,130,130,138,138,138,138,138,138,138,154,
	162,162,162,162,162,162,162,162,170,170,170,170,170,170,170,186,
	162,162,162,162,162,162,162,162,170,170,170,170,170,170,170,186,
	130,130,130,130,130,130,130,130,138,138,138,138,138,138,138,154,
	130,130,130,130,130,130,130,130,138,138,138,138,138,138,138,154,
	162,162,162,162,162,162,162,162,170,170,170,170,170,170,170,186,
	162,162,162,162,162,162,162,162,170,170,170,170,170,170,170,186,
};

/* cbitsTable[i] = (i & 0x10) | ((i >> 8) & 1), i = 0..511 */
static const Byte cbitsTable[512] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
};

/* addTable[i] = ((i & 0xff) << 8) | (i & 0xa8) | (((i & 0xff) == 0) << 6), i = 0..511 */
static const Word addTable[512] = {
	0x0040,0x0100,0x0200,0x0300,0x0400,0x0500,0x0600,0x0700,
	0x0808,0x0908,0x0a08,0x0b08,0x0c08,0x0d08,0x0e08,0x0f08,
	0x1000,0x1100,0x1200,0x1300,0x1400,0x1500,0x1600,0x1700,
	0x1808,0x1908,0x1a08,0x1b08,0x1c08,0x1d08,0x1e08,0x1f08,
	0x2020,0x2120,0x2220,0x2320,0x2420,0x2520,0x2620,0x2720,
	0x2828,0x2928,0x2a28,0x2b28,0x2c28,0x2d28,0x2e28,0x2f28,
	0x3020,0x3120,0x3220,0x3320,0x3420,0x3520,0x3620,0x3720,
	0x3828,0x3928,0x3a28,0x3b28,0x3c28,0x3d28,0x3e28,0x3f28,
	0x4000,0x4100,0x4200,0x4300,0x4400,0x4500,0x4600,0x4700,
	0x4808,0x4908,0x4a08,0x4b08,0x4c08,0x4d08,0x4e08,0x4f08,
	0x5000,0x5100,0x5200,0x5300,0x5400,0x5500,0x5600,0x5700,
	0x5808,0x5908,0x5a08,0x5b08,0x5c08,0x5d08,0x5e08,0x5f08,
	0x6020,0x6120,0x6220,0x6320,0x6420,0x6520,0x6620,0x6720,
	0x6828,0x6928,0x6a28,0x6b28,0x6c28,0x6d28,0x6e28,0x6f28,
	0x7020,0x7120,0x7220,0x7320,0x7420,0x7520,0x7620,0x7720,
	0x7828,0x7928,0x7a28,0x7b28,0x7c28,0x7d28,0x7e28,0x7f28,
	0x8080,0x8180,0x8280,0x8380,0x8480,0x8580,0x8680,0x8780,
	0x8888,0x8988,0x8a88,0x8b88,0x8c88,0x8d88,0x8e88,0x8f88,
	0x9080,0x9180,0x9280,0x9380,0x9480,0x9580,0x9680,0x9780,
	0x9888,0x9988,0x9a88,0x9b88,0x9c88,0x9d88,0x9e88,0x9f88,
	0xa0a0,0xa1a0,0xa2a0,0xa3a0,0xa4a0,0xa5a0,0xa6a0,0xa7a0,
	0xa8a8,0xa9a8,0xaaa8,0xaba8,0xaca8,0xada8,0xaea8,0xafa8,
	0xb0a0,0xb1a0,0xb2a0,0xb3a0,0xb4a0,0xb5a0,0xb6a0,0xb7a0,
	0xb8a8,0xb9a8,0xbaa8,0xbba8,0xbca8,0xbda8,0xbea8,0xbfa8,
	0xc080,0xc180,0xc280,0xc380,0xc480,0xc580,0xc680,0xc780,
	0xc888,0xc988,0xca88,0xcb88,0xcc88,0xcd88,0xce88,0xcf88,
	0xd080,0xd180,0xd280,0xd380,0xd480,0xd580,0xd680,0xd780,
	0xd888,0xd988,0xda88,0xdb88,0xdc88,0xdd88,0xde88,0xdf88,
	0xe0a0,0xe1a0,0xe2a0,0xe3a0,0xe4a0,0xe5a0,0xe6a0,0xe7a0,
	0xe8a8,0xe9a8,0xeaa8,0xeba8,0xeca8,0xeda8,0xeea8,0xefa8,
	0xf0a0,0xf1a0,0xf2a0,0xf3a0,0xf4a0,0xf5a0,0xf6a0,0xf7a0,
	0xf8a8,0xf9a8,0xfaa8,0xfba8,0xfca8,0xfda8,0xfea8,0xffa8,
	0x0040,0x0100,0x0200,0x0300,0x0400,0x0500,0x0600,0x0700,
	0x0808,0x0908,0x0a08,0x0b08,0x0c08,0x0d08,0x0e08,0x0f08,
	0x1000,0x1100,0x1200,0x1300,0x1400,0x1500,0x1600,0x1700,
	0x1808,0x1908,0x1a08,0x1b08,0x1c08,0x1d08,0x1e08,0x1f08,
	0x2020,0x2120,0x2220,0x2320,0x2420,0x2520,0x2620,0x2720,
	0x2828,0x2928,0x2a28,0x2b28,0x2c28,0x2d28,0x2e28,0x2f28,
	0x3020,0x3120,0x3220,0x3320,0x3420,0x3520,0x3620,0x3720,
	0x3828,0x3928,0x3a28,0x3b28,0x3c28,0x3d28,0x3e28,0x3f28,
	0x4000,0x4100,0x4200,0x4300,0x4400,0x4500,0x4600,0x4700,
	0x4808,0x4908,0x4a08,0x4b08,0x4c08,0x4d08,0x4e08,0x4f08,
	0x5000,0x5100,0x5200,0x5300,0x5400,0x5500,0x5600,0x5700,
	0x5808,0x5908,0x5a08,0x5b08,0x5c08,0x5d08,0x5e08,0x5f08,
	0x6020,0x6120,0x6220,0x6320,0x6420,0x6520,0x6620,0x6720,
	0x6828,0x6928,0x6a28,0x6b28,0x6c28,0x6d28,0x6e28,0x6f28,
	0x7020,0x7120,0x7220,0x7320,0x7420,0x7520,0x7620,0x7720,
	0x7828,0x7928,0x7a28,0x7b28,0x7c28,0x7d28,0x7e28,0x7f28,
	0x8080,0x8180,0x8280,0x8380,0x8480,0x8580,0x8680,0x8780,
	0x8888,0x8988,0x8a88,0x8b88,0x8c88,0x8d88,0x8e88,0x8f88,
	0x9080,0x9180,0x9280,0x9380,0x9480,0x9580,0x9680,0x9780,
	0x9888,0x9988,0x9a88,0x9b88,0x9c88,0x9d88,0x9e88,0x9f88,
	0xa0a0,0xa1a0,0xa2a0,0xa3a0,0xa4a0,0xa5a0,0xa6a0,0xa7a0,
	0xa8a8,0xa9a8,0xaaa8,0xaba8,0xaca8,0xada8,0xaea8,0xafa8,
	0xb0a0,0xb1a0,0xb2a0,0xb3a0,0xb4a0,0xb5a0,0xb6a0,0xb7a0,
	0xb8a8,0xb9a8,0xbaa8,0xbba8,0xbca8,0xbda8,0xbea8,0xbfa8,
	0xc080,0xc180,0xc280,0xc380,0xc480,0xc580,0xc680,0xc780,
	0xc888,0xc988,0xca88,0xcb88,0xcc88,0xcd88,0xce88,0xcf88,
	0xd080,0xd180,0xd280,0xd380,0xd480,0xd580,0xd680,0xd780,
	0xd888,0xd988,0xda88,0xdb88,0xdc88,0xdd88,0xde88,0xdf88,
	0xe0a0,0xe1a0,0xe2a0,0xe3a0,0xe4a0,0xe5a0,0xe6a0,0xe7a0,
	0xe8a8,0xe9a8,0xeaa8,0xeba8,0xeca8,0xeda8,0xeea8,0xefa8,
	0xf0a0,0xf1a0,0xf2a0,0xf3a0,0xf4a0,0xf5a0,0xf6a0,0xf7a0,
	0xf8a8,0xf9a8,0xfaa8,0xfba8,0xfca8,0xfda8,0xfea8,0xffa8,
};

/* subTable[i] = ((i & 0xff) << 8) | (i & 0xa8) | (((i & 0xff) == 0) << 6) | 2, i = 0..255 */
static const Word subTable[256] = {
	0x0042,0x0102,0x0202,0x0302,0x0402,0x0502,0x0602,0x0702,
	0x080a,0x090a,0x0a0a,0x0b0a,0x0c0a,0x0d0a,0x0e0a,0x0f0a,
	0x1002,0x1102,0x1202,0x1302,0x1402,0x1502,0x1602,0x1702,
	0x180a,0x190a,0x1a0a,0x1b0a,0x1c0a,0x1d0a,0x1e0a,0x1f0a,
	0x2022,0x2122,0x2222,0x2322,0x2422,0x2522,0x2622,0x2722,
	0x282a,0x292a,0x2a2a,0x2b2a,0x2c2a,0x2d2a,0x2e2a,0x2f2a,
	0x3022,0x3122,0x3222,0x3322,0x3422,0x3522,0x3622,0x3722,
	0x382a,0x392a,0x3a2a,0x3b2a,0x3c2a,0x3d2a,0x3e2a,0x3f2a,
	0x4002,0x4102,0x4202,0x4302,0x4402,0x4502,0x4602,0x4702,
	0x480a,0x490a,0x4a0a,0x4b0a,0x4c0a,0x4d0a,0x4e0a,0x4f0a,
	0x5002,0x5102,0x5202,0x5302,0x5402,0x5502,0x5602,0x5702,
	0x580a,0x590a,0x5a0a,0x5b0a,0x5c0a,0x5d0a,0x5e0a,0x5f0a,
	0x6022,0x6122,0x6222,0x6322,0x6422,0x6522,0x6622,0x6722,
	0x682a,0x692a,0x6a2a,0x6b2a,0x6c2a,0x6d2a,0x6e2a,0x6f2a,
	0x7022,0x7122,0x7222,0x7322,0x7422,0x7522,0x7622,0x7722,
	0x782a,0x792a,0x7a2a,0x7b2a,0x7c2a,0x7d2a,0x7e2a,0x7f2a,
	0x8082,0x8182,0x8282,0x8382,0x8482,0x8582,0x8682,0x8782,
	0x888a,0x898a,0x8a8a,0x8b8a,0x8c8a,0x8d8a,0x8e8a,0x8f8a,
	0x9082,0x9182,0x9282,0x9382,0x9482,0x9582,0x9682,0x9782,
	0x988a,0x998a,0x9a8a,0x9b8a,0x9c8a,0x9d8a,0x9e8a,0x9f8a,
	0xa0a2,0xa1a2,0xa2a2,0xa3a2,0xa4a2,0xa5a2,0xa6a2,0xa7a2,
	0xa8aa,0xa9aa,0xaaaa,0xabaa,0xacaa,0xadaa,0xaeaa,0xafaa,
	0xb0a2,0xb1a2,0xb2a2,0xb3a2,0xb4a2,0xb5a2,0xb6a2,0xb7a2,
	0xb8aa,0xb9aa,0xbaaa,0xbbaa,0xbcaa,0xbdaa,0xbeaa,0xbfaa,
	0xc082,0xc182,0xc282,0xc382,0xc482,0xc582,0xc682,0xc782,
	0xc88a,0xc98a,0xca8a,0xcb8a,0xcc8a,0xcd8a,0xce8a,0xcf8a,
	0xd082,0xd182,0xd282,0xd382,0xd482,0xd582,0xd682,0xd782,
	0xd88a,0xd98a,0xda8a,0xdb8a,0xdc8a,0xdd8a,0xde8a,0xdf8a,
	0xe0a2,0xe1a2,0xe2a2,0xe3a2,0xe4a2,0xe5a2,0xe6a2,0xe7a2,
	0xe8aa,0xe9aa,0xeaaa,0xebaa,0xecaa,0xedaa,0xeeaa,0xefaa,
	0xf0a2,0xf1a2,0xf2a2,0xf3a2,0xf4a2,0xf5a2,0xf6a2,0xf7a2,
	0xf8aa,0xf9aa,0xfaaa,0xfbaa,0xfcaa,0xfdaa,0xfeaa,0xffaa,
};

/* andTable[i] = (i << 8) | (i & 0xa8) | ((i == 0) << 6) | 0x10 | parityTable[i], i = 0..255 */
static const Byte andTable[256] = {
	0x54,0x10,0x10,0x14,0x10,0x14,0x14,0x10,
	0x18,0x1c,0x1c,0x18,0x1c,0x18,0x18,0x1c,
	0x10,0x14,0x14,0x10,0x14,0x10,0x10,0x14,
	0x1c,0x18,0x18,0x1c,0x18,0x1c,0x1c,0x18,
	0x30,0x34,0x34,0x30,0x34,0x30,0x30,0x34,
	0x3c,0x38,0x38,0x3c,0x38,0x3c,0x3c,0x38,
	0x34,0x30,0x30,0x34,0x30,0x34,0x34,0x30,
	0x38,0x3c,0x3c,0x38,0x3c,0x38,0x38,0x3c,
	0x10,0x14,0x14,0x10,0x14,0x10,0x10,0x14,
	0x1c,0x18,0x18,0x1c,0x18,0x1c,0x1c,0x18,
	0x14,0x10,0x10,0x14,0x10,0x14,0x14,0x10,
	0x18,0x1c,0x1c,0x18,0x1c,0x18,0x18,0x1c,
	0x34,0x30,0x30,0x34,0x30,0x34,0x34,0x30,
	0x38,0x3c,0x3c,0x38,0x3c,0x38,0x38,0x3c,
	0x30,0x34,0x34,0x30,0x34,0x30,0x30,0x34,
	0x3c,0x38,0x38,0x3c,0x38,0x3c,0x3c,0x38,
	0x90,0x94,0x94,0x90,0x94,0x90,0x90,0x94,
	0x9c,0x98,0x98,0x9c,0x98,0x9c,0x9c,0x98,
	0x94,0x90,0x90,0x94,0x90,0x94,0x94,0x90,
	0x98,0x9c,0x9c,0x98,0x9c,0x98,0x98,0x9c,
	0xb4,0xb0,0xb0,0xb4,0xb0,0xb4,0xb4,0xb0,
	0xb8,0xbc,0xbc,0xb8,0xbc,0xb8,0xb8,0xbc,
	0xb0,0xb4,0xb4,0xb0,0xb4,0xb0,0xb0,0xb4,
	0xbc,0xb8,0xb8,0xbc,0xb8,0xbc,0xbc,0xb8,
	0x94,0x90,0x90,0x94,0x90,0x94,0x94,0x90,
	0x98,0x9c,0x9c,0x98,0x9c,0x98,0x98,0x9c,
	0x90,0x94,0x94,0x90,0x94,0x90,0x90,0x94,
	0x9c,0x98,0x98,0x9c,0x98,0x9c,0x9c,0x98,
	0xb0,0xb4,0xb4,0xb0,0xb4,0xb0,0xb0,0xb4,
	0xbc,0xb8,0xb8,0xbc,0xb8,0xbc,0xbc,0xb8,
	0xb4,0xb0,0xb0,0xb4,0xb0,0xb4,0xb4,0xb0,
	0xb8,0xbc,0xbc,0xb8,0xbc,0xb8,0xb8,0xbc,
};

/* xororTable[i] = (i << 8) | (i & 0xa8) | ((i == 0) << 6) | parityTable[i], i = 0..255 */
static const Byte xororTable[256] = {
	0x44,0x00,0x00,0x04,0x00,0x04,0x04,0x00,
	0x08,0x0c,0x0c,0x08,0x0c,0x08,0x08,0x0c,
	0x00,0x04,0x04,0x00,0x04,0x00,0x00,0x04,
	0x0c,0x08,0x08,0x0c,0x08,0x0c,0x0c,0x08,
	0x20,0x24,0x24,0x20,0x24,0x20,0x20,0x24,
	0x2c,0x28,0x28,0x2c,0x28,0x2c,0x2c,0x28,
	0x24,0x20,0x20,0x24,0x20,0x24,0x24,0x20,
	0x28,0x2c,0x2c,0x28,0x2c,0x28,0x28,0x2c,
	0x00,0x04,0x04,0x00,0x04,0x00,0x00,0x04,
	0x0c,0x08,0x08,0x0c,0x08,0x0c,0x0c,0x08,
	0x04,0x00,0x00,0x04,0x00,0x04,0x04,0x00,
	0x08,0x0c,0x0c,0x08,0x0c,0x08,0x08,0x0c,
	0x24,0x20,0x20,0x24,0x20,0x24,0x24,0x20,
	0x28,0x2c,0x2c,0x28,0x2c,0x28,0x28,0x2c,
	0x20,0x24,0x24,0x20,0x24,0x20,0x20,0x24,
	0x2c,0x28,0x28,0x2c,0x28,0x2c,0x2c,0x28,
	0x80,0x84,0x84,0x80,0x84,0x80,0x80,0x84,
	0x8c,0x88,0x88,0x8c,0x88,0x8c,0x8c,0x88,
	0x84,0x80,0x80,0x84,0x80,0x84,0x84,0x80,
	0x88,0x8c,0x8c,0x88,0x8c,0x88,0x88,0x8c,
	0xa4,0xa0,0xa0,0xa4,0xa0,0xa4,0xa4,0xa0,
	0xa8,0xac,0xac,0xa8,0xac,0xa8,0xa8,0xac,
	0xa0,0xa4,0xa4,0xa0,0xa4,0xa0,0xa0,0xa4,
	0xac,0xa8,0xa8,0xac,0xa8,0xac,0xac,0xa8,
	0x84,0x80,0x80,0x84,0x80,0x84,0x84,0x80,
	0x88,0x8c,0x8c,0x88,0x8c,0x88,0x88,0x8c,
	0x80,0x84,0x84,0x80,0x84,0x80,0x80,0x84,
	0x8c,0x88,0x88,0x8c,0x88,0x8c,0x8c,0x88,
	0xa0,0xa4,0xa4,0xa0,0xa4,0xa0,0xa0,0xa4,
	0xac,0xa8,0xa8,0xac,0xa8,0xac,0xac,0xa8,
	0xa4,0xa0,0xa0,0xa4,0xa0,0xa4,0xa4,0xa0,
	0xa8,0xac,0xac,0xa8,0xac,0xa8,0xa8,0xac,
};

#define SET_PVS(s)  (((Tmp16_2 >> 6) ^ (Tmp16_2 >> 5)) & 4)
#define SET_PV      (SET_PVS(Tmp16_1))
#define SET_PV2(x)  ((Tmp8_1 == (x)) << 2)

// Memory manipulation functions
// (Must be different for hardware based emulation)
Byte Fetch8(Word Addr) {
	return(Ram[Addr]);
}

void Write8(Word Addr, Byte Value) {
	Ram[Addr] = Value;
}

Word Fetch16(Word Addr) {
#ifdef BIG_ENDIAN
	return((Ram[Addr + 1] << 8) + Ram[Addr]);
#else
	return((Ram[Addr] << 8) + Ram[Addr + 1]);
#endif
}

void Write16(Word Addr, Word Value) {
#ifdef BIG_ENDIAN
	Ram[Addr + 1] = (Value & 0xff);
	Ram[Addr] = ((Value >> 8) & 0xff);
#else
	Ram[Addr] = (Value & 0xff);
	Ram[Addr + 1] = ((Value >> 8) & 0xff);
#endif
}

void TestLoad(void) {	// Loads the memory with a small test application
	int i = 0;

	//	Ram[i++] = 0x00;	// NOP
	Ram[i++] = 0x01;	// LD BC, 0x0F29
	Ram[i++] = 0x29;
	Ram[i++] = 0x0F;
	//	Ram[i++] = 0x02;	// LD (BC), A
	//	Ram[i++] = 0x03;	// INC BC
	//	Ram[i++] = 0x04;	// INC B
	//	Ram[i++] = 0x05;	// DEC B
	//	Ram[i++] = 0x06;	// LD B, 0x7F
	//	Ram[i++] = 0x7F;
	//	Ram[i++] = 0x06;	// LD B, 0x00
	//	Ram[i++] = 0x00;
	//	Ram[i++] = 0x0E;	// LD C, 0x03
	//	Ram[i++] = 0x03;
	//	Ram[i++] = 0x08;	// EX AF, AF'
	//	Ram[i++] = 0x10;	// DJNZ, -2
	//	Ram[i++] = 0xFE;
	Ram[i++] = 0x21;	// LD HL, 0x0200
	Ram[i++] = 0x00;
	Ram[i++] = 0x02;
	Ram[i++] = 0x09;	// ADD HL, BC
	Ram[i++] = 0x76;	// HLT

}

void Z80Init(void) {	// Must be called before anything else

	// Prepare register pair table
	rp[0] = pBC;
	rp[1] = pDE;
	rp[2] = pHL;
	rp[3] = pSP;

	// Prepare second register pair table
	rp2[0] = pBC;
	rp2[1] = pDE;
	rp2[2] = pHL;
	rp2[3] = pAF;

	// Prepare register table
	r[0] = pB;
	r[1] = pC;
	r[2] = pD;
	r[3] = pE;
	r[4] = pH;
	r[5] = pL;
	r[7] = pA;

}

void Z80Reset(void) {	// Resets all Z80 registers (and other stuff) to their initial values
	Byte i;
	for (i = 0; i < 26; i++) {
		Regs[i] = 0;
	}
}

Byte Z80DecodeCB(void) {	// Decodes and executes the CB prefix instruction
	Byte Result = 0;
	Byte x, y, z, p, q;
	Reg8 Tmp8;
	Reg16 Tmp16;

	Instr = Fetch8(PC++);
	x = GetX(Instr);
	y = GetY(Instr);
	z = GetZ(Instr);
	p = GetP(Instr);
	q = GetQ(Instr);

	R++;

	if (x == 0) {						// rot[y] r[z]

	}
	if (x == 1) {						// BIT y, r[z]

	}
	if (x == 2) {						// RES y, r[z]

	}
	if (x == 3) {						// SET y, r[z]

	}
	return(Result);
}

Byte Z80DecodeDD(void) {	// Decodes and executes the CB prefix instruction
	Byte Result = 0;
	Byte x, y, z, p, q;
	Reg8 Tmp8;
	Reg16 Tmp16;

	Instr = Fetch8(PC++);
	x = GetX(Instr);
	y = GetY(Instr);
	z = GetZ(Instr);
	p = GetP(Instr);
	q = GetQ(Instr);

	R++;

	return(Result);
}

Byte Z80DecodeED(void) {	// Decodes and executes the CB prefix instruction
	Byte Result = 0;
	Byte x, y, z, p, q;
	Reg8 Tmp8;
	Reg16 Tmp16;

	Instr = Fetch8(PC++);
	x = GetX(Instr);
	y = GetY(Instr);
	z = GetZ(Instr);
	p = GetP(Instr);
	q = GetQ(Instr);

	R++;

	return(Result);
}

Byte Z80DecodeFD(void) {	// Decodes and executes the CB prefix instruction
	Byte Result = 0;
	Byte x, y, z, p, q;
	Reg8 Tmp8;
	Reg16 Tmp16;

	Instr = Fetch8(PC++);
	x = GetX(Instr);
	y = GetY(Instr);
	z = GetZ(Instr);
	p = GetP(Instr);
	q = GetQ(Instr);

	R++;

	return(Result);
}

Byte Z80Decode(void) {		// Decodes and executes the instruction pointed at by PC
	Byte Result = 0;
	Byte x, y, z, p, q;
	Reg8 Tmp8_1;
	Reg16 Tmp16_1, Tmp16_2;
	Reg32 Tmp32;

	if (Clock) {
		Instr = Fetch8(PC++);
		x = GetX(Instr);
		y = GetY(Instr);
		z = GetZ(Instr);
		p = GetP(Instr);
		q = GetQ(Instr);

		R++;

		if (x == 0) {
			if (z == 0) {
				if (y == 0) {			// NOP
					// Do nothing
				}
				if (y == 1) {			// EX AF,AF'
					Tmp16_1 = AF; AF = AF_; AF_ = Tmp16_1;
				}
				if (y == 2) {			// DJNZ d
					Tmp8_1 = Fetch8(PC++);
					if (--BC) {
						PC += (int8_t)Tmp8_1;
					}
				}
				if (y == 3) {			// JR d
					Tmp8_1 = Fetch8(PC++);
					PC += (int8_t)Tmp8_1;
				}
				if (y > 3) {			// JR cc[y-4], d
					Tmp8_1 = Fetch8(PC++);
					if (y == 4) {		// JR NZ, d
						if (!fZ)
							PC += (int8_t)Tmp8_1;
					}
					if (y == 5) {		// JR Z, d
						if (fZ)
							PC += (int8_t)Tmp8_1;
					}
					if (y == 6) {		// JR NC, d
						if (!fC)
							PC += (int8_t)Tmp8_1;
					}
					if (y == 7) {		// JR C, d
						if (fC)
							PC += (int8_t)Tmp8_1;
					}
				}
			}
			if (z == 1) {
				if (q == 0) {			// LD rp[p], nn
					Tmp16_1 = Fetch16(PC); PC += 2;
					*rp[p] = Tmp16_1;
				}
				if (q == 1) {			// ADD HL, rp[p]
					Tmp32 = HL + *rp[p];
					F = (F & ~0x3b) | ((Tmp32 >> 8) & 0x28) | cbitsTable[(HL ^ *rp[p] ^ Tmp32) >> 8];
					HL = Tmp32;
				}
			}
			if (z == 2) {
				if (q == 0) {
					if (p == 0) {		// LD (BC), A
						Write8(BC, A);
					}
					if (p == 1) {		// LD (DE), A
						Write8(DE, A);
					}
					if (p == 2) {		// LD (nn), HL
						Tmp16_1 = Fetch16(PC); PC += 2;
						Write16(Tmp16_1, HL);
					}
					if (p == 3) {		// LD (nn), A
						Tmp16_1 = Fetch16(PC); PC += 2;
						Write8(Tmp16_1, A);
					}
				}
				if (q == 1) {
					if (p == 0) {		// LD A, (BC)
						A = Fetch8(BC);
					}
					if (p == 1) {		// LD A, (DE)
						A = Fetch8(DE);
					}
					if (p == 2) {		// LD HL, (nn)
						Tmp16_1 = Fetch16(PC); PC += 2;
						HL = Fetch16(Tmp16_1);
					}
					if (p == 3) {		// LD A, (nn)
						Tmp16_1 = Fetch16(PC); PC += 2;
						A = Fetch8(Tmp16_1);
					}
				}
			}
			if (z == 3) {
				if (q == 0) {			// INC rp[p]
					(*rp[p])++;
				}
				if (q == 1) {			// DEC rp[p]
					(*rp[p])--;
				}
			}
			if (z == 4) {				// INC r[y]
				if (y == 6) {
					Tmp8_1 = Fetch8(HL);
					Tmp8_1++;
					Write8(HL, Tmp8_1);
				} else {
					Tmp8_1 = (*r[y]);
					Tmp8_1++;
				}
				F = (F & ~0xfe) | incTable[*r[y]] | SET_PV2(0x80);
			}
			if (z == 5) {				// DEC r[y]
				if (y == 6) {
					Tmp8_1 = Fetch8(HL);
					Tmp8_1--;
					Write8(HL, Tmp8_1);
				} else {
					Tmp8_1 = (*r[y]);
					Tmp8_1--;
				}
				F = (F & ~0xfe) | decTable[*r[y]] | SET_PV2(0x7f);
			}
			if (z == 6) {				// LD r[y], n
				Tmp8_1 = Fetch8(PC++);
				if (y == 6) {
					Write8(HL, Tmp8_1);
				} else {
					(*r[y]) = Tmp8_1;
				}
			}
			if (z == 7) {
				if (y == 0) {			// RLCA
					Tmp8_1 = (A & 0x80) >> 7;
					A = (A << 1) & Tmp8_1;
					F = (F & 0xc4) | (A & 0x28) | Tmp8_1;
				}
				if (y == 1) {			// RRCA
					Tmp8_1 = (A & 0x01);
					A = (A >> 1) & (Tmp8_1 << 7);
					F = (F & 0xc4) | (A & 0x28) | Tmp8_1;
				}
				if (y == 2) {			// RLA
					Tmp8_1 = (A & 0x80) >> 7;
					A = (A << 1) & (F & 0x01);
					F = (F & 0xc4) | (A & 0x28) | Tmp8_1;
				}
				if (y == 3) {			// RRA
					Tmp8_1 = (A & 0x01);
					A = (A >> 1) & (F << 7);
					F = (F & 0xc4) | (A & 0x28) | Tmp8_1;
				}
				if (y == 4) {			// DAA
					Tmp8_1 = A;
					if (fN) {
						if (fH || (A & 0x0f) > 9) Tmp8_1 -= 6;
						if (fC || A > 0x99) Tmp8_1 -= 0x60;
					} else {
						if (fH || (A & 0x0f) > 9) Tmp8_1 += 6;
						if (fC || A > 0x99) Tmp8_1 += 0x60;
					}
					F = (F & 0x03) | parityTable[Tmp8_1] | (A > 0x99) | ((A^Tmp8_1) & 0x10);
					A = Tmp8_1;
				}
				if (y == 5) {			// CPL
					A = ~A;
					F = (F & 0xc5) | (A & 0x28) | 0x12;
				}
				if (y == 6) {			// SCF
					F = (F & 0xc4) | (A & 0x28) | 0x01;
				}
				if (y == 7) {			// CCF
					Tmp8_1 = ~F & 0x01;
					F = (F & 0xc4) | (A & 0x28) | (fC << 4) | Tmp8_1;
				}
			}
		}
		if (x == 1) {
			if (z == 6) {
				if (y == 6) {			// HLT (replaces LD (HL), (HL))
					Result = 1;
				} else {				// LD r[y], (HL)
					Tmp8_1 = Fetch8(HL);
					(*r[y]) = Tmp8_1;
				}
			} else {
				if (y == 6) {			// LD (HL), r[z]
					Write8(HL, (*r[z]));
				} else {				// LD r[y], r[z]
					(*r[y]) = (*r[z]);
				}
			}
		}
		if (x == 2) {					// alu[y] r[z]
			if (z == 6) {
				Tmp8_1 = Fetch8(HL);
			} else {
				Tmp8_1 = (*r[z]);
			}
			if (y == 0) {				// ADD A, r[z]
				Tmp16_1 = A + Tmp8_1;
				Tmp16_2 = A ^ Tmp8_1 ^ Tmp16_1;
				AF = addTable[Tmp16_1] | cbitsTable[Tmp16_2] | (SET_PV);
			}
			if (y == 1) {				// ADC A, r[z]
				Tmp16_1 = A + Tmp8_1 + (fC != 0);
				Tmp16_2 = A ^ Tmp8_1 ^ Tmp16_1;
				AF = addTable[Tmp16_1] | cbitsTable[Tmp16_2] | (SET_PV);
			}
			if (y == 2) {				// SUB r[z]
				Tmp16_1 = A - Tmp8_1;
				Tmp16_2 = A ^ Tmp8_1 ^ Tmp16_1;
				AF = subTable[Tmp16_1 & 0xff] | cbitsTable[Tmp16_2 & 0x1ff] | (SET_PV);
			}
			if (y == 3) {				// SBC A,
				Tmp16_1 = A - Tmp8_1 - (fC != 0);
				Tmp16_2 = A ^ Tmp8_1 ^ Tmp16_1;
				AF = subTable[Tmp16_1 & 0xff] | cbitsTable[Tmp16_2 & 0x1ff] | (SET_PV);
			}
			if (y == 4) {				// AND
				A = A & Tmp8_1;
				F = andTable[A];
			}
			if (y == 5) {				// XOR
				A = A ^ Tmp8_1;
				F = xororTable[A];
			}
			if (y == 6) {				// OR
				A = A | Tmp8_1;
				F = xororTable[A];
			}
			if (y == 7) {				// CP

			}
		}
		if (x == 3) {
			if (z == 0) {				// RET cc[y]

			}
			if (z == 1) {
				if (q == 0) {			// POP rp2[p]

				} else {
					if (p == 0) {		// RET

					}
					if (p == 1) {		// EXX

					}
					if (p == 2) {		// JP HL

					}
					if (p == 3) {		// LD SP,HL

					}
				}

			}
			if (z == 2) {				// JP cc[y], nn

			}
			if (z == 3) {
				if (y == 0) {			// JP nn

				}
				if (y == 1) {			// (CB prefix)
					Z80DecodeCB();
				}
				if (y == 2) {			// OUT (n), A

				}
				if (y == 3) {			// IN A, (n)

				}
				if (y == 4) {			// EX (SP), HL

				}
				if (y == 5) {			// EX DE, HL

				}
				if (y == 6) {			// DI

				}
				if (y == 7) {			// EI

				}
			}
			if (z == 4) {				// CALL cc[y], nn

			}
			if (z == 5) {
				if (q == 0) {			// PUSH rp2[p]

				} else {
					if (p == 0) {		// CALL nn

					}
					if (p == 1) {		// (DD prefix)
						Z80DecodeDD();
					}
					if (p == 2) {		// (ED prefix)
						Z80DecodeED();
					}
					if (p == 3) {		// (FD prefix)
						Z80DecodeFD();
					}
				}
				if (z == 6) {			// alu[y] n

				}
				if (z == 7) {			// RST y*8

				}
			}
		}
	}
	return(Result);
}

int main(void) {
	printf("MyZ80 Test Interface\n");
	printf("Copyright (C) 2016 Marcelo F. Dantas\n");

	Z80Init();

	TestLoad();

	Z80Reset();
	while (true) {
		if (Z80Decode()) {
			break;
		}
	}
}